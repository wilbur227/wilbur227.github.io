<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Unix程序设计（笔记）</title>
      <link href="/2022/10/04/Unix%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1(%E7%AC%94%E8%AE%B0)/"/>
      <url>/2022/10/04/Unix%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1(%E7%AC%94%E8%AE%B0)/</url>
      
        <content type="html"><![CDATA[<h1 id="进程的控制"><a href="#进程的控制" class="headerlink" title="进程的控制"></a>进程的控制</h1><h5 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h5><p>进程由程序、数据、进程控制块三部分组成</p><p>程序：描述进程所要完成的功能</p><p>数据：为进程提供运行所需的堆栈和私有数据</p><p>进程控制块（PCB）：含有进程的描述和控制信息，集中反映进程的动态特性，是系统识别和控制进程的依据。</p><h5 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h5><p>又称负荷进程，是在进程基础上程序的一次执行，一个进程可以拥有多个线程。</p><p>线程没有独立资源，它共享进程ID和进程的资源。</p><p>线程是UNIX中最小的调度单位</p><h5 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h5><p>sysproc：标识号为0,能合理地调度系统中运行的进程，负责将进程从硬盘交换区调入内存或将进程从内存调到硬盘交换区。</p><p>init：标识号为1，系统初始化的进程，是sysproc外所有进程的父进程。</p><h5 id="前台进程和后台进程"><a href="#前台进程和后台进程" class="headerlink" title="前台进程和后台进程"></a>前台进程和后台进程</h5><p>前台进程会接管终端，SHELL不能再输入其他命令直到进程执行完</p><p>在命令串后加上“&amp;”，表示后台执行，后台进程不接管终端</p><h5 id="父子进程"><a href="#父子进程" class="headerlink" title="父子进程"></a>父子进程</h5><p>当一个进程启动另一个进程时，被启动的进程就是子进程，原进程就是父进程。父子进程以并行的方式执行同一程序的不同分支</p><h5 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h5><p>运行态：进程已经分配到CPU正在处理机上执行的状态</p><p>就绪态：进程已具备运行条件，但是其他进程正占用CPU，而暂时不能运行等待分配的状态</p><p>睡眠态：进程正在等待某事件发生而不能运行的状态，睡眠被唤醒后只能进入就绪态不能直接进入运行态。</p><h5 id="进程标识"><a href="#进程标识" class="headerlink" title="进程标识"></a>进程标识</h5><h5 id="进程的创建"><a href="#进程的创建" class="headerlink" title="进程的创建"></a>进程的创建</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">fork</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><p>新创建的进程称为子进程，调用fork()的进程称为父进程</p><p>如果fork()调用失败，返回-1；如果调用成功，则在父进程中返回子进程的标识号，在子进程中返回0。</p><p>创建fork1.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="built_in">fprintf</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="僵尸进程"><a href="#僵尸进程" class="headerlink" title="僵尸进程"></a>僵尸进程</h5><p>已经中止但是没有从进程表中清除的进程。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>成就解锁（日常）</title>
      <link href="/2022/09/30/2022-09-30-%E6%88%90%E5%B0%B1%E8%A7%A3%E9%94%81%EF%BC%88%E6%97%A5%E5%B8%B8%EF%BC%89/"/>
      <url>/2022/09/30/2022-09-30-%E6%88%90%E5%B0%B1%E8%A7%A3%E9%94%81%EF%BC%88%E6%97%A5%E5%B8%B8%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="成就"><a href="#成就" class="headerlink" title="成就"></a>成就</h1><h2 id="已达成"><a href="#已达成" class="headerlink" title="已达成"></a>已达成</h2><h3 id="1-敲代码的猫的博客"><a href="#1-敲代码的猫的博客" class="headerlink" title="1.敲代码的猫的博客"></a>1.敲代码的猫的博客</h3><p>搭建好自己的博客并发布</p><h3 id="4-初来乍到"><a href="#4-初来乍到" class="headerlink" title="4.初来乍到"></a>4.初来乍到</h3><p>参加CODEYA捧杯</p><h3 id="12-最后的礼物"><a href="#12-最后的礼物" class="headerlink" title="12.最后的礼物"></a>12.最后的礼物</h3><p>2022年10月4日提交</p><hr><h2 id="未达成"><a href="#未达成" class="headerlink" title="未达成"></a>未达成</h2><h3 id="2-C-精通"><a href="#2-C-精通" class="headerlink" title="2.C++精通"></a>2.C++精通</h3><p>学完并掌握C++从入门到精通</p><h3 id="3-JAVA精通"><a href="#3-JAVA精通" class="headerlink" title="3.JAVA精通"></a>3.JAVA精通</h3><p>学完并掌握java从入门到精通</p><h3 id="5-JS精通"><a href="#5-JS精通" class="headerlink" title="5.JS精通"></a>5.JS精通</h3><p>学完并掌握javascript从入门到精通</p><h3 id="6-PYTHON精通"><a href="#6-PYTHON精通" class="headerlink" title="6.PYTHON精通"></a>6.PYTHON精通</h3><p>学完并掌握python从入门到精通</p><h3 id="7-C-精通"><a href="#7-C-精通" class="headerlink" title="7.C#精通"></a>7.C#精通</h3><p>学完并掌握C#从入门到精通</p><h3 id="8-算法精通"><a href="#8-算法精通" class="headerlink" title="8.算法精通"></a>8.算法精通</h3><p>学完算法和数据结构</p><h3 id="9-算法达人"><a href="#9-算法达人" class="headerlink" title="9.算法达人"></a>9.算法达人</h3><p>做完100道leecode算法题并提交</p><h3 id="10-项目精通"><a href="#10-项目精通" class="headerlink" title="10.项目精通"></a>10.项目精通</h3><p>做三个小型项目并发布博客分享</p><h3 id="11-项目达人"><a href="#11-项目达人" class="headerlink" title="11.项目达人"></a>11.项目达人</h3><p>做三个中型项目并提交到GITHUB</p><h3 id="13-迟来的四级"><a href="#13-迟来的四级" class="headerlink" title="13.迟来的四级"></a>13.迟来的四级</h3><p>在2022年考过四级</p><h3 id="14-UE4毕业"><a href="#14-UE4毕业" class="headerlink" title="14.UE4毕业"></a>14.UE4毕业</h3><p>学完谌嘉诚的UE4教程视频</p><h3 id="15-我的游戏"><a href="#15-我的游戏" class="headerlink" title="15.我的游戏"></a>15.我的游戏</h3><p>做一款完整的UE4游戏</p><h3 id="16-我爱学习"><a href="#16-我爱学习" class="headerlink" title="16.我爱学习"></a>16.我爱学习</h3><p>补完科林所有视频</p><h3 id="17-笔记达人"><a href="#17-笔记达人" class="headerlink" title="17.笔记达人"></a>17.笔记达人</h3><p>整理各个阶段笔记</p><h3 id="18-爱分享的博主"><a href="#18-爱分享的博主" class="headerlink" title="18.爱分享的博主"></a>18.爱分享的博主</h3><p>做十篇简单技术分享</p><h3 id="19-自律"><a href="#19-自律" class="headerlink" title="19.自律"></a>19.自律</h3><p>一个星期不打游戏</p><h3 id="20-断念"><a href="#20-断念" class="headerlink" title="20.断念"></a>20.断念</h3><p>一个星期不聊天</p><h3 id="21-成就精通"><a href="#21-成就精通" class="headerlink" title="21.成就精通"></a>21.成就精通</h3><p>达成十个成就</p><h3 id="22-成就达人"><a href="#22-成就达人" class="headerlink" title="22.成就达人"></a>22.成就达人</h3><p>达成十个成就</p><h3 id="23-运动健将"><a href="#23-运动健将" class="headerlink" title="23.运动健将"></a>23.运动健将</h3><p>坚持晨跑1周</p><h3 id="24-勤俭持家"><a href="#24-勤俭持家" class="headerlink" title="24.勤俭持家"></a>24.勤俭持家</h3><p>坚持15天不乱花钱</p><h3 id="25-长征"><a href="#25-长征" class="headerlink" title="25.长征"></a>25.长征</h3><p>在30天内节省1000元</p><h3 id="26-启动基金"><a href="#26-启动基金" class="headerlink" title="26.启动基金"></a>26.启动基金</h3><p>攒下5000元不能花</p><h3 id="27-坚持午休"><a href="#27-坚持午休" class="headerlink" title="27.坚持午休"></a>27.坚持午休</h3><p>6：00 起 23：00睡 午睡一小时</p><h3 id="28-敲代码的猫"><a href="#28-敲代码的猫" class="headerlink" title="28.敲代码的猫"></a>28.敲代码的猫</h3><p>坚持敲30天代码</p><h3 id="29-敲代码的狐狸"><a href="#29-敲代码的狐狸" class="headerlink" title="29.敲代码的狐狸"></a>29.敲代码的狐狸</h3><p>坚持敲60天代码</p><h3 id="30-敲代码达人"><a href="#30-敲代码达人" class="headerlink" title="30.敲代码达人"></a>30.敲代码达人</h3><p>坚持敲15天代码</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux高级编程（笔记）</title>
      <link href="/2022/09/27/Linux%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B(%E7%AC%94%E8%AE%B0)/"/>
      <url>/2022/09/27/Linux%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B(%E7%AC%94%E8%AE%B0)/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="Linux高级编程"><a href="#Linux高级编程" class="headerlink" title="Linux高级编程"></a>Linux高级编程</h1><h2 id="1-GitHub-开源项目托管网站-git"><a href="#1-GitHub-开源项目托管网站-git" class="headerlink" title="1.GitHub(开源项目托管网站,git)"></a>1.GitHub(开源项目托管网站,git)</h2><h5 id="1-1GitHub介绍"><a href="#1-1GitHub介绍" class="headerlink" title="1.1GitHub介绍:"></a>1.1GitHub介绍:</h5><p>第三方项目托管网站，很多的企业级代码工程或开源free的代码在此平台上托管，开发者聚集地</p><p>topics:分类标签</p><p>trending:推送标签</p><p>查询关键字:  </p><p>awesome  #好玩的 tutorial #查询文档资料 sample #练习内容和小实例</p><h5 id="1-2CODE-工程资源（代码及其他文件资源）"><a href="#1-2CODE-工程资源（代码及其他文件资源）" class="headerlink" title="1.2CODE #工程资源（代码及其他文件资源）"></a>1.2CODE #工程资源（代码及其他文件资源）</h5><p>README.md #markdown编写的项目自述文档，文档中记录了项目的作业，使用流程，及依赖选项，可以使用和调试</p><p>LICENSE #许可证 在使用前一定要认真阅览许可声明，如果违规使用可能引发法务问题</p><p>几种授权许可，给使用者最大的使用权限，以及最小的限制，用户可以放心的使用此类项目：</p><p>MIT #麻省理工实验室许可证</p><p>Apache #apache基金会许可</p><h5 id="1-3ISSUES-问答标签"><a href="#1-3ISSUES-问答标签" class="headerlink" title="1.3ISSUES #问答标签"></a>1.3ISSUES #问答标签</h5><h5 id="1-4GITHUB三要素："><a href="#1-4GITHUB三要素：" class="headerlink" title="1.4GITHUB三要素："></a>1.4GITHUB三要素：</h5><p>仓库：工程代码资源的存储位置，内部保存用户项目工程的所有数据内容</p><p>Commit 提交：操作上传代码资源时，要进行提交，每次提交GitHub都会记录保存这次提交（添加、删除、修改）开发者随时都可以通过提交记录回溯到某个时刻的修改，找回以前的内容和片段</p><p>Branch分支：</p><h5 id="1-5关联性设置："><a href="#1-5关联性设置：" class="headerlink" title="1.5关联性设置："></a>1.5关联性设置：</h5><p>1.用本地Git软件与Github账号进行关联设置</p><p>2.为云端的仓库地址起别名，便于后期将本地内容上传同步到云端</p><h5 id="1-6Git软件的介绍与Git命令"><a href="#1-6Git软件的介绍与Git命令" class="headerlink" title="1.6Git软件的介绍与Git命令"></a>1.6Git软件的介绍与Git命令</h5><p>Git是一个分布式版本的控制系统，开发使用Git软件可以特别方便的管理云端仓库，对云端内容进行同步，修改，删除等等操作</p><p>ssh -T <a href="mailto:&#103;&#x69;&#x74;&#x40;&#x67;&#x69;&#116;&#x68;&#117;&#98;&#46;&#99;&#111;&#109;">&#103;&#x69;&#x74;&#x40;&#x67;&#x69;&#116;&#x68;&#117;&#98;&#46;&#99;&#111;&#109;</a> #关联认证</p><p>git init #创建本地仓库</p><p>git config –list #查看git配置信息</p><p>git config –global #键值对 #向配置文件中添加配置项user.name user.emali</p><p>ssh-keygen -t rsa -C 邮箱 #创建本地密钥，用于数据传输加密</p><h5 id="1-7配置流程："><a href="#1-7配置流程：" class="headerlink" title="1.7配置流程："></a>1.7配置流程：</h5><p>1.根据生成密钥的存储位置，找到id_rsa.pub公有密钥文件,拷贝其中的密钥字符串</p><p>2.Github云端账号中用户头像位置的下拉菜单，选择settings</p><p>3.SSH and GPG Key，将复制的本地密钥字符串粘贴，Add Keys</p><p>4.ssh -T <a href="mailto:&#103;&#105;&#x74;&#64;&#x67;&#x69;&#116;&#x68;&#117;&#x62;&#46;&#99;&#x6f;&#x6d;">&#103;&#105;&#x74;&#64;&#x67;&#x69;&#116;&#x68;&#117;&#x62;&#46;&#99;&#x6f;&#x6d;</a> #再次测试关联</p><h5 id="1-8定位云端仓库"><a href="#1-8定位云端仓库" class="headerlink" title="1.8定位云端仓库"></a>1.8定位云端仓库</h5><p><a href="mailto:&#103;&#x69;&#116;&#x40;&#x67;&#105;&#x74;&#104;&#x75;&#x62;&#46;&#99;&#x6f;&#109;">&#103;&#x69;&#116;&#x40;&#x67;&#105;&#x74;&#104;&#x75;&#x62;&#46;&#99;&#x6f;&#109;</a>:wilbur227&#x2F;cabbage-0.git</p><p>为云端仓库地址起别名，后续通过别名上传本地内容到云端</p><p>git remote add origin <a href="mailto:&#x67;&#x69;&#x74;&#64;&#103;&#x69;&#116;&#104;&#x75;&#x62;&#x2e;&#99;&#x6f;&#109;">&#x67;&#x69;&#x74;&#64;&#103;&#x69;&#116;&#104;&#x75;&#x62;&#x2e;&#99;&#x6f;&#109;</a>:wilbur227&#x2F;cabbage-0.git</p><p>git remote remove origin #删除别名</p><h5 id="1-9完整代码提交流程"><a href="#1-9完整代码提交流程" class="headerlink" title="1.9完整代码提交流程"></a>1.9完整代码提交流程</h5><p>git add code.cpp #将代码添加到缓冲区</p><p>git status #查看缓冲区内容和状态</p><p>commit -m “首次提交”#将缓冲区内容提交到仓库</p><p>git push origin master#将本地内容同步到云端</p><p>git rm code.cpp #删除备份内容</p><p>git restore code.cpp #还原内容</p><p>git pull –rebase origin master #从云端仓库拉取分支到本地</p><p>git clone “HTTPS的仓库地址”</p><p><a href="https://sm.ms/" title="点击进入sm.ms">图片上传网站</a></p><h2 id="2-Linux基本命令"><a href="#2-Linux基本命令" class="headerlink" title="2.Linux基本命令"></a>2.Linux基本命令</h2><p>ls<br>ls -l<br>ls -a<br>ls -R 递归列出所有文件夹<br>man ls查看命令帮助</p><p>echo输出<br>cd改变文件夹<br>cd ..回到上一个文件夹<br>cd &#x2F;回到根目录<br>cd ~<br>cd<br>pwd 获取文件所在路径</p><p>clear 清屏<br>当唯一确定时tab可以自动补齐<br>mkdir 创建文件夹<br>rmdir 移除文件夹<br>rm -r递归删除<br>rm -rf强制删除不询问<br>touch 创建文件<br>mv（移动文件&#x2F;重命名文件）<br>cp（拷贝文件或内容）<br>vi（打开一个文件编辑）<br>wq保存并退出<br>q直接退出<br>q!不保存退出</p><p>head查看前几行<br>tail查看后几行</p><p>ln 硬链接<br>ln -s软链接<br>wc<br>od<br>du<br>df -h查看磁盘使用情况<br>sudo临时提升权限<br>chmod更改权限<br>chown<br>find<br>grep “return” .&#x2F; -R</p><p>安装和卸载<br>sudo apt-get update<br>sudo apt-get install package</p><p>mount<br>sudo useradd -s 创建用户 </p><p>sudo su切换到root用户</p><p>进程管理：</p><p>ps  aux#监控后台进程</p><p>sp上下分屏</p><p>vsp左右分屏</p><p>Ctr+w+w: 在多个窗口切换</p><h2 id="3-process"><a href="#3-process" class="headerlink" title="3.process"></a>3.process</h2><h5 id="3-1程序和进程的关系"><a href="#3-1程序和进程的关系" class="headerlink" title="3.1程序和进程的关系"></a>3.1程序和进程的关系</h5><p>程序是静态实体（进程的静态表现），进程是动态实例（程序的动态实例）</p><p>程序保存在电脑中占用磁盘资源，进程是程序启动后的执行结果，占用Cpu内存等系统资源</p><h5 id="3-2进程在操作系统中的逻辑形态"><a href="#3-2进程在操作系统中的逻辑形态" class="headerlink" title="3.2进程在操作系统中的逻辑形态"></a>3.2进程在操作系统中的逻辑形态</h5><p>物理内存概念：物理内存大小取决于PC上的内存条设备</p><p>虚拟内存概念：逻辑内存</p><p>PCB（进程控制块，其中包含了进程详细信息，例如：进程id，进程缓存位置，进程启动时间，进程状态等等）</p><p>系统进程数量，取决于PCB数量，如果PCB耗尽则无法创建新进程</p><p>内核层只有系统可以读写访问，用户是没有访问权限的</p><h5 id="3-3内核层-x2F-系统层"><a href="#3-3内核层-x2F-系统层" class="headerlink" title="3.3内核层&#x2F;系统层"></a>3.3内核层&#x2F;系统层</h5><p>PCB（进程控制块）:存储于内核层，包含进程详细信息，例如：进程ID，进程缓存位置，进程启动时间，进程状态</p><h5 id="3-4用户层"><a href="#3-4用户层" class="headerlink" title="3.4用户层"></a>3.4用户层</h5><p>命令行参数与环境变量</p><p>栈(8M)</p><p>Library(库)</p><p>堆</p><p>BSS (未初始化全局数据)</p><p>DATA (已初始化全局数据)</p><p>Text (代码段)</p><p>NULL (哨兵)</p><p><em><strong>系统中复杂繁多的映射关系存储在虚拟内存映射表中，由内存管理器管理和设置</strong></em></p><p><em><strong>内存是共享资源，多个进程可以交替使用</strong></em></p><p>系统进程数量取决于PCB数量，如果PCB耗尽则无法创建新进程</p><h5 id="3-5内存单位"><a href="#3-5内存单位" class="headerlink" title="3.5内存单位"></a>3.5内存单位</h5><p>page(页) 1page &#x3D; 4096Bytes, 1page &#x3D; 8k , 1page &#x3D; 16k</p><h5 id="3-6内存的权限"><a href="#3-6内存的权限" class="headerlink" title="3.6内存的权限"></a>3.6内存的权限</h5><p>PROT_READ(只读)</p><p>PROT_WRITE(只写)</p><p>PROT_NONE(无)</p><p>PROT_EXEC(执行)</p><h2 id="4-ipc"><a href="#4-ipc" class="headerlink" title="4.ipc"></a>4.ipc</h2><h2 id="5-thread"><a href="#5-thread" class="headerlink" title="5.thread"></a>5.thread</h2><h2 id="6-thread-safa"><a href="#6-thread-safa" class="headerlink" title="6.thread_safa"></a>6.thread_safa</h2><h2 id="7-soket套接字"><a href="#7-soket套接字" class="headerlink" title="7.soket套接字"></a>7.soket套接字</h2><p>套接字技术用于网络应用开发，各个语言和操作系统都有对套接字的支持和实现，对开发者而言，网络是一个比较宽泛的概念，但是套接字函数的学习和使用是开发者的必备技能。socket套接字技术即使操作系统提供给开发者使用一系列针对网络应用开发的函数接口(Socket API)</p><h5 id="7-1-在Linux下socket的类型及定义"><a href="#7-1-在Linux下socket的类型及定义" class="headerlink" title="7.1.在Linux下socket的类型及定义"></a>7.1.在Linux下socket的类型及定义</h5><p>int sockfd   </p><p>（IP、PORT）</p><p>SockerPair  </p><p>sockfd是网络通信的主要部件</p><p>socket描述符</p><h5 id="7-2-网络信息结构体"><a href="#7-2-网络信息结构体" class="headerlink" title="7.2.网络信息结构体"></a>7.2.网络信息结构体</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in_addr</span></span></span><br><span class="line"><span class="class"><span class="title">addr</span>.<span class="title">sin_family</span> =</span> AF_INET | AF_INET6</span><br><span class="line">addr.<span class="built_in">sin</span>.addr.s.addr = 存储大端IP</span><br><span class="line">addr.<span class="built_in">sin</span> port = 存储大端端口</span><br></pre></td></tr></table></figure><h5 id="7-3-大小端转换函数"><a href="#7-3-大小端转换函数" class="headerlink" title="7.3.大小端转换函数"></a>7.3.大小端转换函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">htons() #小端转大端端口号</span><br><span class="line">htonl() #小端转大端IP</span><br><span class="line"><span class="title function_">ntohs</span><span class="params">()</span> #大端转小端端口号</span><br><span class="line"><span class="title function_">ntohl</span><span class="params">()</span> #大端转小端IP</span><br><span class="line"><span class="title function_">inet_ntop</span><span class="params">()</span> #大端IP转为字符串IP</span><br><span class="line"><span class="title function_">inet_pton</span><span class="params">()</span> #字符串IP转为大端序IP</span><br></pre></td></tr></table></figure><h5 id="7-4-socket套接字函数"><a href="#7-4-socket套接字函数" class="headerlink" title="7.4.socket套接字函数"></a>7.4.socket套接字函数</h5><p>1.Socket创建</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> sockfd = socket(AF_INET,SOCK_STREAM|SOCK_DGRAM,<span class="type">int</span> protocal) #最后参数传<span class="number">0</span>表示默认协议，常指TCP\UDP</span><br><span class="line">RETURN:成功返回sockfd，失败返回<span class="number">-1</span>,并且设置errno,进行错误处理</span><br></pre></td></tr></table></figure><p>2.socket创建后直接可以使用，ip为本地任意ip，端口为随机端口</p><p>3.Bind，使用网络信息结构体与sockfd进行绑定设置，设置替换sockfd中的网络信息。(tcp,udp)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> Result = bind(<span class="type">int</span> sockfd,struct_sockaddr *addr,<span class="type">socklen_t</span> addrlen) #使用自定义网络结构体设置修改sockfd</span><br><span class="line">RETURN:绑定设置成功返回<span class="number">0</span>，绑定设置失败返回<span class="number">-1</span>，设置errno，进行错误处理</span><br></pre></td></tr></table></figure><p>4.Listen,监听网络连接状态(tcp)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Listen(<span class="type">int</span> sockfd, <span class="type">int</span> Backlog)参数为监听的sockfd,设置监听序列的大小</span><br><span class="line">RETURN:调用成功，返回<span class="number">0</span>，失败返回<span class="number">-1</span>，设置errno,进行错误处理</span><br></pre></td></tr></table></figure><p>5.Connect,请求连接函数（TCP）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> Result = connect(<span class="type">int</span> Mysockfd,sockaddr* destAddr，<span class="type">socklen_t</span> addrlen)#阻塞连接函数</span><br><span class="line">RETURN:连接成功，返回<span class="number">0</span>，失败返回<span class="number">-1</span>，设置errno,进行错误处理，如果因网络问题无法及时连接，connect会阻塞连接</span><br></pre></td></tr></table></figure><p>6.Accept,等待连接函数（TCP）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> Result = Accept(<span class="type">int</span> server_fd,sockaddr* clientsaddr,<span class="type">socklen_t</span>* addrlen)#</span><br><span class="line">RETURN:成功返回客户端sockfd，失败返回<span class="number">-1</span>，设置errno,进行错误处理</span><br><span class="line">    </span><br><span class="line">    addrlen传出传入参数：传入你可以接收的网络信息结构体，传出实际大小。</span><br></pre></td></tr></table></figure><p>7.Socket读写函数、</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> recvlen = recv(<span class="type">int</span> sockfd,<span class="type">const</span> <span class="type">char</span>* buffer,<span class="type">size_t</span> len,<span class="type">int</span> flag) #读写socket数据函数</span><br><span class="line"><span class="type">ssize_t</span> slen = send(<span class="type">int</span> sockfd,<span class="type">const</span> <span class="type">char</span>* buffer,<span class="type">size_t</span> len,<span class="type">int</span> flag)#将本机数据通过send发送</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="8-服务器编程"><a href="#8-服务器编程" class="headerlink" title="8.服务器编程"></a>8.服务器编程</h2><p>服务器基本概述：企业级后台服务软件，各种软件客户端无法脱离服务器技术，服务器为各样的功能软件提供后台支持，技术支持，数据支持等等</p><p>服务器软件执行周期较长（7*24）小时不间断执行</p><h5 id="8-1服务器种类："><a href="#8-1服务器种类：" class="headerlink" title="8.1服务器种类："></a>8.1服务器种类：</h5><p>1.软件服务器CS</p><p>自行设计服务器组织架构，协议指定，协议状态机数据处理，千万级并发中转交互</p><p>设计实现取决于软件的功能与用户的需求</p><p>自定义协议（封装tcp&#x2F;udp）</p><p>2.web服务器BS</p><p>使用HTTP协议（基于TCP实现）</p><h5 id="8-2服务器的职责与作用"><a href="#8-2服务器的职责与作用" class="headerlink" title="8.2服务器的职责与作用"></a>8.2服务器的职责与作用</h5><p>1.网络穿透</p><p>客户端连接时向服务器提交网络信息</p><p>保存客户端最新的网络信息</p><p>为独立无关联的客户端中转数据，建立通信渠道，实现通信效果</p><p>2.高并发能力</p><p>并发能力是一个服务器的基本能力，并发数量（并发处理数量），多个用户可以同时连接访问服务器，服务器 一对多完成度，是服务器的重要性能指标。</p><p>3.安全性</p><p>访问权限校验，数据通信加密，隔离机制（反向代理服务器），防火墙策略和设置</p><p>4.存储能力</p><p>缓存临时数据，持久化用户数据等待（磁盘存储，数据存储（mysql,raides,oracle,sqlserver））</p><p>5.业务处理</p><p>处理客户端请求，完成特定任务</p><h5 id="8-3服务器操作系统："><a href="#8-3服务器操作系统：" class="headerlink" title="8.3服务器操作系统："></a>8.3服务器操作系统：</h5><p>服务器操作系统市场占有率最高的是linux\unix操作系统，cantOs,ubuntu,Linux服务器系统稳定，安全性，可用性较高，也有很多windows服务器系统</p><h5 id="8-4开源服务器软件"><a href="#8-4开源服务器软件" class="headerlink" title="8.4开源服务器软件"></a>8.4开源服务器软件</h5><p>Apache服务器</p><p>Nginx服务器</p><p>无需用户过多干预，设置配置，搭建服务流程结构，实现业务主体，即可投入使用</p><h5 id="8-5-功能性服务器"><a href="#8-5-功能性服务器" class="headerlink" title="8.5 功能性服务器"></a>8.5 功能性服务器</h5><p>处理服务器</p><p>文件服务器</p><p>数据库服务器</p><p>代理服务器（中转）</p><p>分布式服务器集群：由海量服务主机设备构成，实现资源共享（网络实现进程通信），统一管理，统一设置</p><h5 id="负载均衡策略："><a href="#负载均衡策略：" class="headerlink" title="负载均衡策略："></a>负载均衡策略：</h5><h5 id="代理服务器作用："><a href="#代理服务器作用：" class="headerlink" title="代理服务器作用："></a>代理服务器作用：</h5><h5 id="HA高可用模型："><a href="#HA高可用模型：" class="headerlink" title="HA高可用模型："></a>HA高可用模型：</h5><h5 id="TPS-QPS-吞吐量，压力测试，负载测试等等服务器性能指标："><a href="#TPS-QPS-吞吐量，压力测试，负载测试等等服务器性能指标：" class="headerlink" title="TPS,QPS,吞吐量，压力测试，负载测试等等服务器性能指标："></a>TPS,QPS,吞吐量，压力测试，负载测试等等服务器性能指标：</h5><h5 id="服务器开发："><a href="#服务器开发：" class="headerlink" title="服务器开发："></a>服务器开发：</h5><p>本章代码，主要放在服务器的设计实现，优化上，客户端实现基本功能即可（连接与断开，响应系统时间）</p><p>对简单的客户端服务器模型进行补充，对套接字函数进行二次包裹便于使用，实现一个简单业务，客户端通过timeofday关键向服务器请求系统时间，服务器进行反馈响应</p><p>对于socket套接字函数的二次包裹，网络研发工程师会根据使用系统，对函数或库函数进行包裹，将套接字函数的错误处理包裹起来，便于使用</p><h5 id="单进程服务端测试DEMO-1-1"><a href="#单进程服务端测试DEMO-1-1" class="headerlink" title="单进程服务端测试DEMO(1:1)"></a>单进程服务端测试DEMO(1:1)</h5><h5 id="多进程并发模型-1-N"><a href="#多进程并发模型-1-N" class="headerlink" title="多进程并发模型(1:N)"></a>多进程并发模型(1:N)</h5><h2 id="9-正则表达式"><a href="#9-正则表达式" class="headerlink" title="9.正则表达式"></a>9.正则表达式</h2><h2 id="10-阶段项目"><a href="#10-阶段项目" class="headerlink" title="10.阶段项目"></a>10.阶段项目</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>敲代码的猫的博客（日常）</title>
      <link href="/2022/09/26/%E6%95%B2%E4%BB%A3%E7%A0%81%E7%9A%84%E7%8C%AB%E7%9A%84%E5%8D%9A%E5%AE%A2(%E6%97%A5%E5%B8%B8)/"/>
      <url>/2022/09/26/%E6%95%B2%E4%BB%A3%E7%A0%81%E7%9A%84%E7%8C%AB%E7%9A%84%E5%8D%9A%E5%AE%A2(%E6%97%A5%E5%B8%B8)/</url>
      
        <content type="html"><![CDATA[<h5 id="今天阿猫搭建好了自己的博客，纪念一下吧"><a href="#今天阿猫搭建好了自己的博客，纪念一下吧" class="headerlink" title="今天阿猫搭建好了自己的博客，纪念一下吧~"></a>今天阿猫搭建好了自己的博客，纪念一下吧~</h5><p><img src="https://s2.loli.net/2022/09/27/AGzE9U2LFQk53Tx.jpg" alt="e82ad33443f80ddaa3b6320f5f8db92.jpg"></p><h5 id="之后阿猫会定期更新一些编程心得和日常（暗中观察）"><a href="#之后阿猫会定期更新一些编程心得和日常（暗中观察）" class="headerlink" title="之后阿猫会定期更新一些编程心得和日常（暗中观察）"></a>之后阿猫会定期更新一些编程心得和日常（暗中观察）</h5><p><img src="https://s2.loli.net/2022/09/27/U1ucCsB2njhiqgm.jpg" alt="0d697434065cf5a0fa29fbe84fb622d.jpg"></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
